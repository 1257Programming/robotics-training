# Commands

Now that we have the structure of the `subsystem` down, we have to design `commands` to actually control it. At any given point, there can be one `command` running on the `subsystem`.

## Structure of a Command

Code for a command is more specific and constrained than that of a `subsystem`. The program must specify the command's features in its possible "states", i.e. when the command is initialized, executed, and ended. (Not to be confused with "states" of a subsystem!)

Here are all of the methods that we normally modify, listed in a sequential structure:
- `initialize()` - what is run exactly once when the command is scheduled; usually used to place the command in a *known* starting state
- `execute()` - what is run every loop while the command is active; used to run the desired action
- `isFinished()` - returns a boolean for when the command is finished executing and can be ended -- where you define *when exactly* the command is terminated
- `end()` - called once when the command is finished (when `isFinished()` returns true) or is interrupted by another command; usually used to clean up variables/code
- `interrupted()` - what happens when the command is interrupted by another command (normally just calls `end()`)

## Command Example

For a `subsystem` like the roller intake we have been working with, we would have 3 main `commands.`
- NeutralCargoCommand - keeps the intake in the neutral state
- IntakeCargoCommand - sets the intake to be intaking
- EjectCargoCommand - sets the intake to be ejecting

These are the 3 main actions we want to perform with our intake. Next, we have to consider when we want these commands to be run.

- NeutralCargoCommand - whenever the operator isn't pressing anything, this should be scheduled
- IntakeCargoCommand - while the operator is holding a button like the B button, this should be scheduled
- EjectCargoCommand - while the operator is holding a button like the A button, this should be scheduled

Now that we have this planning out of the way, we can get to actually programming our commands.

## Basic Code

```java
public class NeutralCargoCommand extends CommandBase {

    private final Intake m_intake;

    public NeutralCargoCommand(Intake intake) {
        m_intake = intake;

        addRequirements(m_intake);
    }

    @Override
    public void initialize() {

    }

    @Override
    public void execute() {
        m_intake.neutral();
    }

    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public void end() {
        
    }

    @Override
    public void interrupted() {
        end();
    }
}
```

Scroll up and look at the list above in order to remind yourself what each of these functions do. In this case, what we want our command to do is that while active on our `Intake` subsystem, it will constantly run the `intake.neutral()` function, which sets the intake to the neutral `state`.

Observe what occurs in the constructor of the `command`. Essentially, it stores a reference to the `subsystem` it uses, which in this case is `intake`. An instance of the subsystem must be explicitly passed in when the command is called such that the command can use the subsystem's methods. Then, there's the line `addRequirements(m_intake)`. This defines which `subsystem` the command is for. Additionally, it tells the `CommandScheduler` what subsystem is being referenced such that it can prevent two commands of the same subsystem running simultaneously. 

Another thing to note is the naming of `m_intake`. The "m_" is nothing special in terms of programming -- it is simply notation to avoid having the line `intake = intake` inside the command's constructor.

## Setting Default Commands

"Default commands" of a subsystem are run when no other command is using said subsystem. In the case of our roller intake, the default command would be `NeutralCargoCommand`, since we want the intake to run at a constant speed when there is no user input.

Setting the default command for a subsystem is not too difficult. Simply go back into `RobotContainer.java` and add this line into its constructor:

**`m_intake.setDefaultCommand(new NeutralCargoCommand(m_intake));`**

This line assumes that `m_intake` is a defined member of `RobotContainer`, on which we call `setDefaultCommand()` while also passing it in as a parameter.

## The Other Commands

For brevity, the code for `IntakeCargoCommand` and `EjectCargoCommand` won't be included, since they're practically copies of `NeutralCargoCommand` using `m_intake.intake()` or `m_intake.eject()` instead of `m_intake.neutral()`.

Now that we have these commands defined, the last step is to define *when* these commands will be called, which we will do next.
