# Subsystems

Each subsystem in our robot code is in its own `class`, which is in its own file. As mentioned before, a subsystem represents some mechanism or collection of hardware on the robot. In the `class` are the subsystem's data and methods that can be referenced later in the `commands`. 

For the purpose of this demonstration, we will consider one of the most simple types of subsystems we commonly build: a roller intake. To visualize this, we will utilize our 2019 robot for the game Destination: Deep Space.

<img src=img/2019Robot.jpg width=500> <img src=img/CargoBall.jpeg width=200>

The subsystem of focus here is the green wheeled mouth system, which is our roller intake for taking in the cargo balls.

Essentially, there is a single motor hooked up to those wheels, and when it is run, the intake can take in cargo. When it is run the other way, it will eject them. We build these **a lot**, so if you can understand how to program this, it will greatly help.

## Basic Code

```java
package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class Intake extends SubsystemBase {
    
    public Intake() {

    }

    /**
     * Called periodically when run by the CommandScheduler
     */
    @Override
    public void periodic() {

    }
}
```

This is the basic boilerplate code for a subsystem. One thing to notice is that this `Intake` extends the `SubsystemBase` class, which is included in WPILib (note the corresponding import statement). Overall, this subclassing is necessary for `command-based` to work. The `periodic()` function can be used to update subsystem-specific states. Generally, we want to make this in a new file called `Intake.java` and put it inside of a folder called `subsystems`.

## Actuators

The next step is to implement the actual actuators (motors, pistons) that are on our subsystem. In this case, we have a single `WPI_VictorSPX` that controls the roller. Note that we *will* need the `Phoenix.json` vendor dependency and a corresponding import statement.

```java
package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

public class Intake extends SubsystemBase {
    
    private WPI_VictorSPX intakeMotor;

    public Intake() {
        intakeMotor = new WPI_VictorSPX(0);
    }

}
```

## States

Next, we have to consider something called the `state` of the `subsystem`. Essentially, a `state` is a configuration that we could put the `subsystem` into. Let's consider the intake, which has some of the most simple `states`.

The intake has three `states`:
 - NEUTRAL - doing nothing
 - INTAKING - spinning inwards to take in a ball
 - EJECTING - spinning outwards to eject a ball

## States in Code

At any time, the subsystem will have a variable that refers to the current state of the subsystem. We use an `enum` to represent this state.

```java
package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

public class Intake extends SubsystemBase {
    
    private WPI_VictorSPX intakeMotor;

    public enum State {
        NEUTRAL,
        INTAKING,
        EJECTING
    }
    private State state = State.EJECTING;

    public Intake() {
        intakeMotor = new WPI_VictorSPX(0);
    }

}
```

## Updating our State

Now that we have a variable to represent the internal state of our subsystem, we have to be able to somehow update that state and change it. The way we do this is by creating various functions within our class that will change the state to the corresponding value.

```java
package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

public class Intake extends SubsystemBase {
    
    private WPI_VictorSPX intakeMotor;

    public enum State {
        NEUTRAL,
        INTAKING,
        EJECTING
    }
    private State state = State.EJECTING;

    public Intake() {
        intakeMotor = new WPI_VictorSPX(0);
    }

    public void neutral() {
        state = State.NEUTRAL;
    }

    public void intake() {
        state = State.INTAKING;
    }

    public void eject() {
        state = State.EJECTING;
    }
}
```

We will reference these functions when creating our commands.

Now, we have a variable to represent the current state of the intake, but we aren't actually doing anything with that state. The way we actually use it is through an `update()` function that looks at the current state and updates all of the actuators accordingly.

In this case, we want to set the speed of `intakeMotor` depending on the state.

```java
package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

public class Intake extends SubsystemBase {
    
    private WPI_VictorSPX intakeMotor;

    public enum State {
        NEUTRAL,
        INTAKING,
        EJECTING
    }
    private State state = State.EJECTING;

    public Intake() {
        intakeMotor = new WPI_VictorSPX(0);
    }

    public void update() {
        switch(state) {
        case NEUTRAL:
            intakeMotor.set(0);
            break;
        case INTAKING:
            intakeMotor.set(-1.0);
            break;
        case EJECTING:
            intakeMotor.set(1.0);
            break;
        }
    }

    public void neutral() {
        state = State.NEUTRAL;
    }

    public void intake() {
        state = State.INTAKING;
    }

    public void eject() {
        state = State.EJECTING;
    }
}
```

## Using RobotContainer.java

Now that we have created the class for our intake in `Intake.java`, it is time to actually add this code to `RobotContainer.java`. We first have to create an instance of the `Intake`, and then we must utilize it.

```java
package frc.robot;

import edu.wpi.first.wpilibj.*;

public class RobotContainer {

    private final Intake m_intake = new Intake();

    public RobotContainer() {
        // call configureButtonBindings() and other things here
    }

    public void updateSubsystems() {
        m_intake.update();
    }

    private void configureButtonBindings() {
        // map buttons to commands in here (reference SnailController)
    }
    
}
```

After writing out the `RobotContainer` structure and placing our own `updateSubsystems()` method, we can now instantiate `RobotContainer` inside `Robot.java`, and call what is necessary.

```java
package frc.robot;

import edu.wpi.first.wpilibj.*;

public class Robot extends TimedRobot {

    private RobotContainer robotContainer;

    @Override
    public void robotInit() {
        //this instance will take care of any button bindings
        robotContainer = RobotContainer.getInstance();
    }

    @Override 
    public void robotPeriodic() {
        CommandScheduler.getInstance().run();
    }

    @Override
    public void teleopInit() {

    }

    @Override
    public teleopPeriodic() {
        robotContainer.updateSubsystems();
    }
}
```

## Next Steps

Now, the overall structure of our intake is pretty well defined. Next up, we will look at how we actually go about using commands to control it.
