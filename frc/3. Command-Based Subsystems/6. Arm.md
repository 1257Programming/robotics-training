# Arm

A commonly used subsystem is an arm. Let's take 1257's 2019 full intake arm and go through an example command-based program with it.

<img src="img/2019RobotRaised.jpg" width=450> 

On this robot, the arm is a mechanism that moves in a space of ~90 degrees, allowing for some degree of freedom. It allows for ground pickup of cargo and ejection of the ball in various places. The arm is hooked up to one motor going through a gearbox, enabling the driver to control the arm manually.

Hence, we have *one possible state already: manual control*. One could also use a control loop to move the arm towards precise positions, but we'll skip over that in this section, however. (See the [Higher Topics section](https://github.com/FRC1257/robotics-training/tree/master/frc/4.%20Higher%20Topics/PID) for more information.) We will structure our program here as if we had multiple states, but will only include the `MANUAL` state.

## The Subsystem

```java
public class IntakeArm extends SubsystemBase {

    private WPI_VictorSPX armMotor;
    private double speed;

    public enum State {
        MANUAL
    }
    private State state = State.MANUAL;

    public IntakeArm() {
        armMotor = new WPI_VictorSPX(0);
        speed = 0;
    }

}
```

We will leave the import statements out in these snippets, but that doesn't mean they are unnecessary. So far, we've created our subsystem, declared our speed variable and `WPI_VictorSPX` motor, and set up our enum. The next step would be to add a method that can manipulate the enum state, and an `update()` method that would actually perform the movement.

```java
public class IntakeArm extends SubsystemBase {

    private WPI_VictorSPX armMotor;
    private double speed;

    public enum State {
        MANUAL
        // could add more states here
    }
    private State state = State.MANUAL;

    public IntakeArm() {
        armMotor = new WPI_VictorSPX(0);
        speed = 0;
    }

    public void update() {
        switch (state) {
        case MANUAL:
            armMotor.set(speed);
            break;
        // could add more states here

        }
        
        speed = 0;
    }

    public void setSpeed(double value) {
        speed = value;

        if (speed != 0) {
            state = State.MANUAL;
        }
    }
}
```

Similar to the roller intake subsystem, the `update()` method here uses a switch statement to check for potential states and manipulate the cargo arm accordingly. Observe once again how the final action is performed within `update()` and not in `setSpeed()`. Instead, we have `setSpeed()` take in an input and assign it to the final motor output variable, `speed`. Finally, we set `speed` to zero in order to reset it at the end of each loop.  

Ultiamtely, this type of structure allows for smooth expansion in the future (i.e. adding other states to manipulate `speed` differently) and provides a simple path for commands to do their work.

## The Command(s)

Now it's time to make our arm's commands. For now, we'll only have one, named `IntakeArmCommand`.

```java
public class IntakeArmCommand extends CommandBase {

    private IntakeArm m_intakeArm;
    private OI oi;

    public IntakeArmCommand(IntakeArm intakeArm) {
        m_intakeArm = intakeArm;
        oi = OI.getInstance();

        addRequirements(m_intakeArm);
    }

    @Override
    public void initialize() {

    }

    @Override
    public void execute() {
        m_intakeArm.setSpeed(oi.getCargoArmSpeed());
    }

    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public void end() {

    }

    @Override
    public void interrupted() {
        end();
    }
}
```

So, we've done a few things here:
- We referenced the defined `m_intakeArm` variable, and set it as a requirement. We also accessed the `OI` class using the pre-defined `getInstance()` method. 
- For the command's execution, we referenced the `setSpeed()` method from the subsystem, and passed in `oi.getCargoArmSpeed`. This assumes that `getCargoArmSpeed()` is a defined method in `OI` returning the y-axis value of a controller's joystick. 
- The controller input is then sent through `setSpeed()` and into the subsystem's `update()`, moving the arm as a result.

## Binding 

Alright, so we've programmed both the subsystem and its command. The next step would be to bind the command to the controller -- however, we don't have to do that in this case. Instead, we can call this line: 

**`m_intakeArm.setDefaultCommand(new IntakeArmCommand(m_intakeArm));`**

in the constructor of `RobotContainer`, assuming that `m_intakeArm` is a defined instance of the `IntakeArm` subsystem inside the `RobotContainer` class. This way, the arm is always looking for controller input unless it is in a controlled-state.  

Full code can be found in the `/programs/` folder.




