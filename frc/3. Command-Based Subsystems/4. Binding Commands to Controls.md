# Binding Commands

We will link our commands to controller inputs through `RobotContainer.java`.

Take a look at its basic structure:

```java
public class RobotContainer {

    private static RobotContainer instance = null;

    private SnailController driveController;
    private SnailController operatorController;

    private RobotContainer() {
        driveController = new SnailController(0);
        operatorController = new SnailController(1);
    }

    public static RobotContainer getInstance() {
        if (instance == null) {
            instance = new RobotContainer();
        }
        return instance;
    }
}
```

We make `RobotContainer` in a new file called `RobotContainer.java`, which should reside in the same directory as `Robot.java`.

Note something peculiar: we use `private` in the constructor for `RobotContainer` and we have a function called `getInstance()`. This is something known as a **`singleton`**. It's not too common in classes we use, but it's a good concept to know (see [here](https://www.geeksforgeeks.org/singleton-class-java/) for more details). Essentially, whenever we want to access `RobotContainer`, we use `RobotContainer.getInstance()`, rather than creating a new `RobotContainer` object.

The next interesting thing is the usage of two objects, of type `SnailController`.

`SnailController` is a class developed by 1257 as a way to use Xbox controllers with command-based programming easily. We can just drop the `SnailController.java` file into our project in a folder called `util`, and we don't really have to touch it anymore. It's a utility file that has already been programmed, so we don't have to worry about it. A copy of `SnailController.java` is included in the `/programs/` folder.

## Binding Controls to Commands

With `SnailController`, binding commands to the buttons is very easy. We want to run the `IntakeCargoCommand` when the B button is pressed on our operator controller. And then we want the `EjectCargoCommand` to be run when the A button is pressed.

```java
public class RobotContainer {

    private static RobotContainer instance = null;
    private Intake m_intake;

    private SnailController driveController;
    private SnailController operatorController;

    private RobotContainer() {
        m_intake = new Intake();
        m_intake.setDefaultCommand(new NeutralCargoCommand(m_intake));

        driveController = new SnailController(0);
        operatorController = new SnailController(1);

        configureButtonBindings();
    }

    private void configureButtonBindings() {
        operatorController.bButton.whileHeld(new IntakeCargoCommand(m_intake));
        operatorController.aButton.whileHeld(new EjectCargoCommand(m_intake));  
    }

    public void updateSubsystems() {
        intake.update();
    }

    public static RobotContainer getInstance() {
        if (instance == null) {
            instance = new RobotContainer();
        }
        return instance;
    }
}
```

Essentially, for each controller, we can access a variable for each of the buttons. Then, we can call a function on each of these variables to configure a command to be run when a certain action is applied to it. Here are a few pre-programmed actions that you can use:

- `whenPressed()` - runs the command once when the button is first pressed
- `whileHeld()` - runs the command continuously while the button is pressed
- `whenReleased()` - runs the command once when the button is released
- `toggleWhenPressed()` - toggles the running of a command when the button is pressed

In our bindings, passing in `m_intake` as the subsystem is required for the command to work. Also, note how we placed our controls in `configureButtonBindings()`, and later into the constructor. Calling an instance of `RobotContainer` in `Robot` will take care of running `configureButtonBindings()`.

Now that we've done this, our roller intake is complete! The full code for this can be found within the `/programs/` folder.
