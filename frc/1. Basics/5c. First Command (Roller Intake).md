# Command (Roller Intake)

With our subsystem file finished and filled with constants, it is now time to go onto the next big topic: Commands.

## What are commands?

The purpose of a command is to make the robot actually complete an action such as intaking, ejecting, or even staying in a neutral state. As a result, there is usually one command per state. These commands eventually get called by other parts of the robot code when an action needs to be done.

## Command File Format

Now that the basic definiton of a command has been gone over it is time to go over a Command File and its format. For the sake of this tuturorial this command will take care of the intak
```java
package frc.robot.commands.rollerIntake;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.RollerIntake;

public class RollerIntakeIntakeCommand extends CommandBase {

    public RollerIntakeIntakeCommand() 
    }

    @Override
    public void initialize() {
    }

    @Override
    public void execute() {
    }

    @Override
    public void end(boolean interrupted) {
    }

    @Override
    public boolean isFinished() {
    }
}
```

Now we will briefly look over the purpose of the constructor and the functions
### `public RollerIntakeIntakeCommand()`

This is the consructor for the  command. All this deals with is defining the intake for usage in the subsequent functions.

### `public void initialize()`

This is usually not used by the team though it is important to know that this runs only once when a command is scheduled/called. Therefore, only things that will not change like motor speed constants are set here. Also if a certain values may be reset some here.

### `public void execute()` 

This function runs constantely while the command is running. In fact it runs every 20 ms. Team 1257 uses this to change the state of the subsystem.

### `public void end(boolean interrupted)`

The end function is run once when the command finishes. It is usually used for reverting the subsystem back to the default state though occcsionally, it is used for other things like setting variables to certain values.

### `public boolean isFinished()`

This function is run as often as the `execute()` function and is in charge of setting the conditions for which the command should stop running.

## Adding Functionality

Now that we have the skeleton of the subsystem out of the way, we can start programming the command.

### The Package, Necessary Imports and Class Declaration

```java
package frc.robot.commands.rollerIntake;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.RollerIntake;



public class RollerIntakeIntakeCommand extends CommandBase {
...
```

* The package is very self explanatory. The file is within a folder called rollerIntake which is inside of commands.
* The first import is a wpilib file called commandBase. This takes care of the functionality of a command and its methods.
* The second import is the subsystem that this command uses. If there are multiple subsystems used, there are multiple imports.
* Lastly, there is the class declaration which is called `Subsystem+Command`. The notable thing is that it extends CommandBase just like subsytems extend SnailSubsystem which extends SubsystemBase. Many useful functions are given because of the inheritance.

### Declaring The Intake, Making the Constructor and Initializing the Robot
```java
public class RollerIntakeIntakeCommand extends CommandBase {

    RollerIntake rollerIntake;
    
    public RollerIntakeIntakeCommand(RollerIntake rollerIntake) {
        this.rollerIntake = rollerIntake;
    
        addRequirements(rollerIntake);
    }
    
    @Override
    public void initialize() {
    }
```

* The first thing we do in the command is declare the subsystem we will be using. 
* Then, we proceed to define the subsystem using the object passed through the constructor. The whereabouts of original object passed in are not currently relevant though it will become important in future lessons.
* After that is `addRequirements(rollerIntake)`. The purpose of addRequirements is for the scheduler to know which subsystems are being used for commands. If the scheduler sees two commands running that have the rollerIntake as a requirement, it will cancel one of the commands.
* Lastly, is `initialize()` function. There is currently nothing inside of it as this is a basic command. Though it is still not deleted in case there will be a future need of it.

### Changing The Subsystem State
```java
    @Override
    public void initialize() {
    }
    
    @Override
    public void execute() {
        rollerIntakke.intake();
    }
```
In the execute function there is only one line and this line is entirely responsible for actually making the robot enter the `INTAKING` state. In our subsystem file, we made function called `intake()`.

```java
    public void intake() {
        state = State.INTAKING;
    }
```
By calling this function we change the state to INTAKING which triggers the update function to respond.
```java
@Override
public void update() {
    switch(state) {
        case NEUTRAL:
            rollerIntakeMotor.set(0.0);
            break;
        case INTAKING:
            rollerIntakeMotor.set(1.0);
            break;
        case EJECTING:
            rollerIntakeMotor.set(-1.0
            break;
        }
}
```
The motor controller then sets the `rollerIntakeMotor` to 1.0.
### Ending The Command

With the main purpose of the complete, it is now time to end it.

```java
@Override
    public void execute() {
        rollerIntakke.intake();
    }

    @Override
    public void end(boolean interrupted) {
        rollerIntake.neutral();
    }

    @Override
    public boolean isFinished() {
        return false;
    }
}
```
* The *end ()* function is called when the command is finished running. In this specific end function, the rollerIntake is reverted to the `neutral` state which is the default for the RollerIntake subsystem. 
* As for the specifics of the logic that triggers the function, there is a boolean passed in called `interrupted`. If this command is cancelled or interrupted with another command, the boolean becomes true and this function is called.

* The `isFinished()` function is in charge of giving the conditions for which a command ends. By default there false is returned which means that the function is not over. Though, if the command is stopped because it is interupted, the false becomes true and the function triggers the ending of this command and the running of a new one. 
* In other implementations of this function we can make the return statement have logic in it. For example we can  make the command end (return true) if a certain button is pressed.

## All The Code In The Lesson Together

Below is all of the code we did in this lesson compiled. It would bec completely functional assuming the command was actually run in another file.
```java
package frc.robot.commands.rollerIntake;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.RollerIntake;

public class RollerIntakeIntakeCommand extends CommandBase {

    RollerIntake rollerIntake;
    
    public RollerIntakeIntakeCommand(RollerIntake rollerIntake) {
        this.rollerIntake = rollerIntake;
    
        addRequirements(rollerIntake);
    }

    @Override
    public void initialize() {
    }
    
    @Override
    public void execute() {
        rollerIntake.intake();
    }

    @Override
    public void end(boolean interrupted) {
        rollerIntake.neutral();
    }

    @Override
    public boolean isFinished() {
        return false;
    }
}
```
## Changes In The Other Two Commands

Although we only went over the `RollerIntakeIntakeCommand`, there are two other commands for subsystem(one for each state.) In each of the commands there are a few small yet very important differences. 

### RollerIntakeEjectCommand 

In this command everything is eactly the same except for the `execute()` function. Instead of calling `intake()`, it calls `eject()` which changes the state to `EJECTING`. Otherwise they are identical.

```java
 @Override
    public void execute() {
        rollerIntake.eject();
    }
```
### RollerIntakeNeutralCommand

In this command there is another key differene other than the `execute()` function. In the `end()` function instead of setting the state to `NEUTRAL`, nothing is written. That is because the original state was already in `NEUTRAL`. Below are the two modified functions.

```java
    @Override
    public void execute() {
        rollerIntake.neutral();
    }

    @Override
    public void end(boolean interrupted) {
    }
```
## Summary
Today we learned how to make commands and how they relate to what a subsystem does. Next lesson, we will learn how the commands actually get called. If you have any questions about this lesson, feel free to ask a senior programming member.
