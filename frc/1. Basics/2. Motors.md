# Motors

## Terminology

An actuator is defined as "a component of a machine that is responsible for moving and controlling a mechanism or system." For our purposes, we need only consider *motors* and *pneumatics*. 

Our robot is essentially entirely made up of motors. All moving components are controlled by motors or pneumatics, and our job as programmers is to figure out how to convert drive team input into the robot actually doing its job. For instance, programming can make sure that certain motors move when drive team pushes buttons or joysticks on a game controller.

First, some clarification:

- *motor* - the actual physical part that spins
- *motor controller* - facilitator that takes in and sends signal to control the motor accordingly

Motors are widely used throughout most, if not all of our robot's subsystems, e.g. on the drivetrain. At the time of writing, 1257 mainly uses NEO Brushless and NEO 550 motors, by REV Robotics. 

<img src="img/SPARKMAX.png" width="330" height=""> <img src="img/NEOvs550.png" width="330"> 

To control these motors and actually manipulate a robot mechanism, we interface with the corresponding motor controllers--this is what we do in code. A NEO-type motor is controlled with a SPARK MAX controller (also by REV Robotics).

## Setup & Control

We need to do a couple of things in our program before actually controlling a motor: 

1. `CANSparkMax motor;` - Declare a SPARK MAX motor controller 
2. `motor = new CANSparkMax(0, MotorType.kBrushless);` - Initialize the object with an ID (0 in this case) and set it to interface with a Brushless motor
3. `motor.setIdleMode(IdleMode.kBrake);` - Set the motor to "brake" mode
4. `motor.setSmartCurrentLimit(80);` - Set a current limit of 80 amps to the motor
5. `import ...;` - Done all of the above with the corresponding vendor dependency file and imports (WPILib-VSCode should assist you with this, or you can refer to old 1257 code)

Read more here on [Brushed vs. Brushless motors](https://cordlessdrillzone.com/drill-wars/brushless-vs-brushed-motor/) and [Brake vs. Coast mode](https://www.chiefdelphi.com/t/what-is-brake-coast-mode/163649). As for current limiting, it's **absolutely necessary** to set an appropriate limit as a safety, such that risk of overdrawing/damaging the motor is reduced.

A great feature of the SPARK MAX controller is that it can handle both brushless (NEO) and brushed motors (CIM, miniCIM, BAG, etc). This versatility is very convenient for teams that have many brushed motor spares, as it allows for quick motor replacement if a NEO/NEO 550 is broken. If a motor change from brushless to brushed is made, all that needs to be updated is `MotorType.kBrushless` to `MotorType.kBrushed`, and vice versa.

Now, to apply power to the motor, we use `motor.set(VALUE)`. "VALUE" is a decimal between -1.0 and 1.0, with 1.0 meaning full speed forward, 0.0 meaning no speed/movement, and -1.0 meaning full speed reverse.

## Note

SPARK MAXes are not the only motor controllers we could use--in the past, 1257 has used Talon SRXs, Victor SPXs, and more. 

While the motor controller may differ, the general process of controlling the motor is most the same. If Talon SRXs were being used, changes would go towards the class name (now `WPI_TalonSRX`) and any functions taken from that class (e.g. `setIdleMode()` would go to `setNeutralMode()`).

<hr>

We will organize all of this material into an actual subsystem class soon--the important part here is *how* to actually work with a motor in our programs.