# First Subsystem(Roller Intake)

Now that we have gone over what the command-based paradigm is and what actuators are, we can now try programming our first subsystem: a roller intake.
Before we start programming it, it is important to understand what it actually is.

## Subsystem Description

![intake](img/rollerintake.jpg)

The image above is the intake of 1257's robot for the 2019 game Destination Deep Space. The wheels on the outside of the intake roll inwards to take in balls. It can then eject the balls by spinning outward. While the ball is within the intake, we will keep it in place by not spinning the wheels at all.

These wheels were moved by a motors which were controlled by motor controllers (the things we actually program). For the purposes of this tuturial, we will assume that SPARK MAXes were used. Now that we have the subsystem basics out of the way, it's time to start coding!

## Snail Subsystem

Before we make our file that represents the subsystem in code, there is one file in our template which is essential: `SnailSubsystem.java`. This file is essentially an abstract class that each subsystem class extends in order to gain key abstract functions. For a refresh on what abstract classes are and their uses go to our [Polymorphism page](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/4.%20Objects/6.%20Polymorphism.md).

Here is a copy of the SnailSubsystem code.

```java

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

public abstract class SnailSubsystem extends SubsystemBase {

    public abstract void update();
    public abstract void outputValues();
    public abstract void setUpConstantTuning();
    public abstract void getConstantTuning();
}
```

**Now for the line by line review:**

* The first line simply declares the package that the file is in
* The second line imports the file `SubsystemBase` from WPILib which we will use next.
* The next line actually makes the class, which extends `SubsystenBase`. This essentially defines that our Subsystem can be recognized by WPILib as part of their command-based paradigm.
* The next four lines have four functions which are all abstract and have to be defined in the subsystems that inherit this class.

## The Actual Subsystem File

We will start with the below code for our subsystem.

```java
package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {


    public enum State {
    }

    public RollerIntake() {

    }

    @Override
    public void update() {

    }

    @Override
    public void outputValues() {

    }

    @Override
    public void setUpConstantTuning() {

    }

    @Override
    public void getConstantTuning() {

    }

    public State getState() {
        return state;
    }
}
```

**Now for the line by line review:**

* At the very top of the file is the package listed out
* Then, several imortant `import`s related to the SPARK MAX(s) that could be used in the subsystem were made
* Then come three more `import` statements that immport to sections of the Constants file (The place where all constants that relate to the robot are stored).
  * The Electrical Layout is where all the motor IDs are stored so the code know which motor to control.
  * The Roller Intake Section has constants that only relate to the subsystem such as motor speeds.
* In the next line the class is declared which notably extends SnailSubsystem which means that its abstract functions are inherited.

The next part of the line by line review will be done in sections.

### `public enum State`

The first chunk of code is when an enum called State is declared. Just like the name suggest, this will keep track of the state of the subsystem. Like previously mentioned a state can be something like intaking or ejecting. Every subsystem will have different states doing different things. If you need a refresher on enums go to our [enums page](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/2.%20Control-Flow/7.%20Enums.md).

### `public RollerIntake()`

This is the constructor for the subsystem. Things like motors, their settings and certain variables are defined here. Every Subsystem has one.

### `public void update()`

This function is responsible for making the robot do things based off of the state. For example, this function could make a motor spin forward if the state was intake. This function is run by the robot 50 times per second during a match so it is very reponsive.

### `public State getState()`

This function is very self explanatory. It simply returns the state of the robot. That can be very useful when the state needs to be accessed from another file.

### All Other Functions

All of the other functions are related to extra functionality that we will go over at another time such as outputting data.

## Adding Functionality

Now that we have the skeleton of the subsystem out of the way, we can go into the specific functionality for this subsystem

```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {

    private final CANSparkMax rollerIntakeMotor;

    public enum State {
        INTAKE,
        EJECT,
        NEUTRAL
    }

    State state = State.NEUTRAL;

    public RollerIntake() {
        rollerIntakeMotor = new CANSparkMax(ElectricalLayout.INTAKE_MOTOR_ID, MotorType.kBrushless);
        rollerIntakeMotor.restoreFactoryDefaults();
        rollerIntakeMotor.setIdleMode(IdleMode.kBrake);
        rollerIntakeMotor.setSmartCurrentLimit(NEO_550_CURRENT_LIMIT);
    }

    @Override
    public void update() {
        switch(state) {
            case NEUTRAL:
                rollerIntakeMotor.set(Constants.Intake.INTAKE_NEUTRAL_SPEED);
                break;
            case INTAKING:
                rollerIntakeMotor.set(Constants.Intake.INTAKE_INTAKE_SPEED);
                break;
            case EJECTING:
                rollerIntakeMotor.set(Constants.Intake.INTAKE_EJECT_SPEED);
                break;
        }
    }

    public State getState() {
        return state;
    }
}
```

Now with all of the code in, let's talk about what it does.

1. After the import statements, the motor controller is declared. Though, it is not defined. This is so it could be defined and accessed later in the code.

2. After that, the states are declared in enum. The three states declared are `INTAKING`, `EJECTING`, and `NEUTRAL`. The state was then set to neutral. This makes logical sense as when the robot just turns on it should not be moving until given the command.

3. Then comes the constructor. For the most part all that is being done here is the defining of the motor conroller and the settings. All of these lines are wrtitten with the format of `rollerIntakeController.function()`. This signfied that these are functions that belong to the object that we created.

   a. when declaring a SPARK MAX motor controller, there are two parameters: The motor ID (currently set to a constant that we will define and review later) and the motor type. Since in this case we are using NEO brushless motors, we will use `kBrushless` for the type.

   b. `restoreFactoryDefaults()` wipes all settings on the motor controller to ensure we know exactly what they are and then we can change what we want.

   c. The next line sets the idle mode of our motor to brake mode, which essentially means that the motor will try to stop itself from moving when we give it a command of `0`.

   d. Lastly we set the current limit. If a motor experiences too much current it could get seriously damaged. This line of code makes sure the motor never gets to that point. We will go over this in more detail at a later point.

4. In the update function, a switch statement is used to do certain actions with the motor by using the motor controller that was just created based off of the current state. `set()` is a function that takes in a value from -1.0 to 1.0 which tells a motor to either spin forwards or backwards. Currently the parameters are from the constant file that has yet to be created.

## Conclusion

Now that we have a feel for what a basic subsystem file has we will be exploring how make the constants in our next lesson. If you have any questions or concerns about this lesson, feel free to ask a senior programmer.
