# First Subsystem (Roller Intake)

Now that we have gone over what the command-based paradigm is and what actuators are, we can now try programming our first subsystem!

## Subsystem Structure

For our robot program, a subsystem is any major mechanism on our robot that archives a task, whether it be picking up game pieces, transporting them, or scoring them. In code, our subsystem is represented by **actuators** and **sensors**. We will cover sensors later, so we will just focus on actuators for now. In code, we also use something called a `state machine` to handle the actions of our subsystem. What this means is that for all of our subsystem, they will have an "operating mode," or a state assigned to it at all times. For example, an intake could have the states "intaking", "ejecting", and "neutral".

Once we have this state stored in our code, every time we want to update our subsystem and send commands to its respective actuators, we will check what our state is and do the respective action. For example, if our state is telling us that our subsystem should be ejecting, we will set the motors accordingly.

Now that we have an idea of how subsystems are structured in code, let's look at one of the simplest: a roller intake.

## Roller Intake Description

![intake](img/rollerintake.jpg)

The image above is the intake of 1257's robot for the 2019 game Destination Deep Space. The wheels on the outside are connected to a single motor and motor controller combination. Then that motor can spin inwards to take in balls. It can then eject the balls by spinning outward. While the ball is within the intake, we will keep it in place by not spinning the wheels at all.

For this tutorial, we will assume that a SPARK MAX were used. Now that we have the subsystem basics out of the way, it's time to start coding!

## Snail Subsystem

Before we make our file that represents the subsystem in code, there is one file in our template which is essential: `SnailSubsystem.java`. This file is essentially an abstract class that each subsystem class extends to gain key abstract functions. For a refresh on what abstract classes are and their uses go to our [Polymorphism page](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/4.%20Objects/6.%20Polymorphism.md).

Here is a copy of the `SnailSubsystem` code.

```java

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

public abstract class SnailSubsystem extends SubsystemBase {

    public abstract void update();
    public abstract void outputValues();
    public abstract void setUpConstantTuning();
    public abstract void getConstantTuning();
}
```

**Now for the line by line review:**

* The first line simply declares the package that the file is in
* The second line imports the file `SubsystemBase` from WPILib which we will use next.
* The next line makes the class, which extends `SubsystemBase`. This essentially defines that our Subsystem can be recognized by WPILib as part of their command-based paradigm.
* The next four lines have four functions which are all abstract and have to be defined in the subsystems that inherit this class.

## Programming The Roller Intake

We will start with the below basic skeleton for our subsystem.

```java
package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

public class RollerIntake extends SnailSubsystem {

    public enum State {

    }

    public RollerIntake() {

    }

    @Override
    public void update() {

    }

    @Override
    public void outputValues() {

    }

    @Override
    public void setUpConstantTuning() {

    }

    @Override
    public void getConstantTuning() {

    }

    public State getState() {
        return state;
    }
}
```

**Now for the line by line review:**

* At the very top of the file is the package listed out
* Then, several important `import`s related to the SPARK MAX(s) that could be used in the subsystem were made
* In the next line, the class is declared which notably extends SnailSubsystem which means that its abstract functions are inherited.

The next part of the line by line review will be done in sections.

### `public enum State`

The first chunk of code is when an enum called `State` is declared. Just like the name suggests, this will keep track of the state of the subsystem. If you need a refresher on enums, go to our [enums page](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/2.%20Control-Flow/7.%20Enums.md).

### `public RollerIntake()`

This is the constructor for the subsystem. Things like motor controllers, their settings, sensors, and certain variables are defined here. Every subsystem has one.

### `public void update()`

This function is responsible for making the robot do things based off of the state. For example, this function could make a motor spin forward if the state was set to intaking. This function is run by the robot 100 times per second at the moment during a match, so it is very responsive.

### `public State getState()`

This function is very self-explanatory. It simply returns the state of the robot. That can be very useful when the state needs to be accessed from another file.

### All Other Functions

All of the other functions are related to extra functionality, such as outputting data, that we will go over at another time.

## Adding Functionality

Now that we have the skeleton of the subsystem out of the way, we can start programming the subsystem.

### Declaring The Motor Controllers

```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {

    private final CANSparkMax rollerIntakeMotor;
    ...
}
```

The first thing that is usually done when making a subsystem is the declaration of the necessary motor controllers that are a part of this subsystem. In this subsystem, we only have one `CANSparkMax`, as described in the beginning. After this declaration, the rest of the code can define and use the motor controller. Notice that there is a final keyword before the declaration of the object to prevent its value from changing after it is defined.

### Making The States

```java

public class RollerIntake extends SnailSubsystem {

    private final CANSparkMax rollerIntakeMotor;

    public enum State {
        INTAKE,
        EJECT,
        NEUTRAL
    }

    State state = State.NEUTRAL;

    ...
```

Next, the states of the subsystem should be thought of and declared in the top enum. For our intake, there are three main "operating modes" that it can be in: ejecting a game piece, intaking a game piece, or being in the neutral point. These correspond with what we call `states` of the subsystem, which is what we are representing with the enum. The three states declared are `INTAKING`, `EJECTING`, and `NEUTRAL` as each of them represents a different operation the robot would have to perform. Our enum will define that all of these possible states can exist, and then the actual `state` variable below holds which current state we are in. It is going to have a default value of `NEUTRAL`, and this makes logical sense as when the robot just turns on it should not be moving until given the command.

### Making The Constructor

```java

 public RollerIntake() {
        rollerIntakeMotor = new CANSparkMax(ElectricalLayout.INTAKE_MOTOR_ID, MotorType.kBrushless);
        rollerIntakeMotor.restoreFactoryDefaults();
        rollerIntakeMotor.setIdleMode(IdleMode.kBrake);
        rollerIntakeMotor.setSmartCurrentLimit(NEO_550_CURRENT_LIMIT);
    }
    ...
```

After declaring the states that the motor would be in, the motor controller is defined and its numerous settings are set. All of these lines are written with the format of `rollerIntakeController.function()`. This signifies that these are functions that belong to the motor controller object that we created in the very beginning.

1. when declaring a SPARK MAX motor controller, there are two parameters: The motor ID (currently set to a constant that we will define and review later) and the motor type. Since in this case we are using NEO brushless motors, we will use `kBrushless` for the type.

2. `restoreFactoryDefaults()` wipes all settings on the motor controller to ensure we know exactly what they are and then we can change what we want.

3. The next line sets the idle mode of our motor to **brake** mode, which essentially means that the motor will try to stop itself from moving when we give it a command of `0`.

4. Lastly, we set the current limit. If a motor experiences too much current it could get seriously damaged. This line of code makes sure the motor never gets to that point. We will go over this in more detail at a later point, but just know that it is something you should know about and we must always do.

### Update Function

```java

   @Override
    public void update() {
        switch(state) {
            case NEUTRAL:
                rollerIntakeMotor.set(0.0);
                break;
            case INTAKING:
                rollerIntakeMotor.set(1.0);
                break;
            case EJECTING:
                rollerIntakeMotor.set(-1.0);
                break;
        }
    } 
    ...
```

Once both the states and the motor controllers are declared, the update function is made. Its main purpose is to look at the current state via the state variable and determine what action it should be doing at the time. To determine the task based off the state, a `switch()` statement is used in conjunction with the enum. In this case, the motor's speed is set to the appropriate values according to the state.

To do this, a function called `set()` is used which has the purpose of taking in a value from -1.0 to 1.0 which tells a motor to either spin backward or forwards.

### Making Methods To Trigger State Changes

```java

    public void neutral() {
        state = State.NEUTRAL;
    }

    public void eject() {
        state = State.EJECTING;
    }

    public void intake() {
        state = State.INTAKING;
    }
}
```

We are almost done with our subsystem file, but the final thing we have to do is to make sure we have functions to update that `state`. We simply can define three functions that have the purpose of sending this subsystem into a different state. For instance, if our subsystem if currently at the `NEUTRAL` state and is just sitting idly, and then we call something like `rollerIntake.intake()`, it will transition it into the `INTAKING` state and the subsystem will continue to remain in that state until that state is changed.

You may ask, what's the point of keeping the `state` variable private and go through all of this trouble to make 3 whole functions to set it? This practice in programming is known as *encapsulation* and essentially hides the `state` variable from direct modification. This is useful because it prevents the `state` from being set improperly to a value such as `null`, or, when we get into PID, prevents the state from getting set without the necessary other requirements being met.

### All The Code In The Lesson Together

Below is all the code that was completed during this lesson. This would make up a fully working subsystem file assuming it has the correct supporting files like commands, which we will go over soon.

```java
package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {

    private final CANSparkMax rollerIntakeMotor;

    public enum State {
        INTAKE,
        EJECT,
        NEUTRAL
    }

    State state = State.NEUTRAL;

    public RollerIntake() {
        rollerIntakeMotor = new CANSparkMax(ElectricalLayout.INTAKE_MOTOR_ID, MotorType.kBrushless);
        rollerIntakeMotor.restoreFactoryDefaults();
        rollerIntakeMotor.setIdleMode(IdleMode.kBrake);
        rollerIntakeMotor.setSmartCurrentLimit(NEO_550_CURRENT_LIMIT);
    }

    @Override
    public void update() {
        switch(state) {
            case NEUTRAL:
                rollerIntakeMotor.set(0.0);
                break;
            case INTAKING:
                rollerIntakeMotor.set(1.0);
                break;
            case EJECTING:
                rollerIntakeMotor.set(-1.0);
                break;
        }
    }

    public void neutral() {
        state = State.NEUTRAL;
    }

    public void eject() {
        state = State.EJECTING;
    }

    public void intake() {
        state = State.INTAKING;
    }

    public State getState() {
        return state;
    }
}
```

## Conclusion

Now that we have a feel for what a basic subsystem file has we will be exploring how to make the constants in our next lesson. If you have any questions or concerns about this lesson, feel free to ask a senior programmer.
