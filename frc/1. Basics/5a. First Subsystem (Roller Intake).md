# First Subsystem(Roller Intake)

Now that we have gone over what the command-based paradigm is and what actuators are, we can now try programming our first subsystem: a roller intake.
Before we start programming it, it is important to understand what it actually is.

## Subsystem Description

![intake](img/rollerintake.jpg)

The image above is the intake of 1257's robot for the 2019 game Destination Deep Space. The wheels on the outside of the intake roll inwards to take in balls. It can then eject the balls by spinning outward. While the ball is within the intake, we will keep it in place by not spinning the wheels at all.

These wheels were moved by a motors which were controlled by motor controllers (the things we actually program). For the purposes of this tuturial, we will assume that SPARK MAXes were used. Now that we have the subsystem basics out of the way, it's time to start coding!

## Snail Subsystem

Before we make our file that represents the subsystem in code, there is one file in our template which is essential: `SnailSubsystem.java`. This file is essentially an abstract class that each subsystem class extends in order to gain key abstract functions. For a refresh on what abstract classes are and their uses go to our [Polymorphism page](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/4.%20Objects/6.%20Polymorphism.md).

Here is a copy of the SnailSubsystem code.

```java

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

public abstract class SnailSubsystem extends SubsystemBase {

    public abstract void update();
    public abstract void outputValues();
    public abstract void setUpConstantTuning();
    public abstract void getConstantTuning();
}
```

**Now for the line by line review:**

* The first line simply declares the package that the file is in
* The second line imports the file `SubsystemBase` from WPILib which we will use next.
* The next line actually makes the class, which extends `SubsystenBase`. This essentially defines that our Subsystem can be recognized by WPILib as part of their command-based paradigm.
* The next four lines have four functions which are all abstract and have to be defined in the subsystems that inherit this class.

## The Actual Subsystem File

We will start with the below code for our subsystem.

```java
package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {


    public enum State {
    }

    public RollerIntake() {

    }

    @Override
    public void update() {

    }

    @Override
    public void outputValues() {

    }

    @Override
    public void setUpConstantTuning() {

    }

    @Override
    public void getConstantTuning() {

    }

    public State getState() {
        return state;
    }
}
```

**Now for the line by line review:**

* At the very top of the file is the package listed out
* Then, several imortant `import`s related to the SPARK MAX(s) that could be used in the subsystem were made
* Then come three more `import` statements that immport to sections of the Constants file (The place where all constants that relate to the robot are stored).
  * The Electrical Layout is where all the motor IDs are stored so the code know which motor to control.
  * The Roller Intake Section has constants that only relate to the subsystem such as motor speeds.
* In the next line the class is declared which notably extends SnailSubsystem which means that its abstract functions are inherited.

The next part of the line by line review will be done in sections.

### `public enum State`

The first chunk of code is when an enum called State is declared. Just like the name suggest, this will keep track of the state of the subsystem. Like previously mentioned a state can be something like intaking or ejecting. Every subsystem will have different states doing different things. If you need a refresher on enums go to our [enums page](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/2.%20Control-Flow/7.%20Enums.md).

### `public RollerIntake()`

This is the constructor for the subsystem. Things like motor conrollers, their settings, sensors and certain variables are defined here. Every subsystem has one.

### `public void update()`

This function is responsible for making the robot do things based off of the state. For example, this function could make a motor spin forward if the state was intake. This function is run by the robot 50 times per second during a match so it is very reponsive.

### `public State getState()`

This function is very self explanatory. It simply returns the state of the robot. That can be very useful when the state needs to be accessed from another file.

### All Other Functions

All of the other functions are related to extra functionality that we will go over at another time such as outputting data.

## Adding Functionality

Now that we have the skeleton of the subsystem out of the way, we can start programming the subsystem. 

### Declaring The Motor Controllers

```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {

    private final CANSparkMax rollerIntakeMotor;
    ...
}
```
The first thing that is usually done when making a subsystem is the declaration of the neccesary motor controllers. In this subsystem we only have one CANSparkMax so only it is declared. After this declaration the rest of the code can define and use the motor controller. Notice that it there is a final keyword before the declaration of the object in order to prevent its value to be changed after it is defined. This is primarily so code wont accidentally mess up the motor controller which would mess up the corresponding motor and the robot.

### Making The States

```java

 public enum State {
        INTAKE,
        EJECT,
        NEUTRAL
    }

    State state = State.NEUTRAL;
    ...
```

Next the states of the subsystem should be thought of and declared in enum. The three states declared are `INTAKING`, `EJECTING`, and `NEUTRAL` as each of them represent a different operation the robot would have to preform. Then a variable representing the current state state was declared and then set to `NEUTRAL`. This makes logical sense as when the robot just turns on it should not be moving until given the command.

### Making The Constructor
```java

 public RollerIntake() {
        rollerIntakeMotor = new CANSparkMax(ElectricalLayout.INTAKE_MOTOR_ID, MotorType.kBrushless);
        rollerIntakeMotor.restoreFactoryDefaults();
        rollerIntakeMotor.setIdleMode(IdleMode.kBrake);
        rollerIntakeMotor.setSmartCurrentLimit(NEO_550_CURRENT_LIMIT);
    }
    ...
```

After declaring the states that the motor would be in the motor controller is defined and its numerous settings are set.  All of these lines are written with the format of `rollerIntakeController.function()`. This signfies that these are functions that belong to the motor controller object that we created in the very beginning.

   1. when declaring a SPARK MAX motor controller, there are two parameters: The motor ID (currently set to a constant that we will define and review later) and the motor type. Since in this case we are using NEO brushless motors, we will use `kBrushless` for the type.

   2. `restoreFactoryDefaults()` wipes all settings on the motor controller to ensure we know exactly what they are and then we can change what we want.

   3. The next line sets the idle mode of our motor to brake mode, which essentially means that the motor will try to stop itself from moving when we give it a command of `0`.

   4. Lastly we set the current limit. If a motor experiences too much current it could get seriously damaged. This line of code makes sure the motor never gets to that point. We will go over this in more detail at a later point.

### Function to Update The States

```java

   @Override
    public void update() {
        switch(state) {
            case NEUTRAL:
                rollerIntakeMotor.set(0.0);
                break;
            case INTAKING:
                rollerIntakeMotor.set(1.0);
                break;
            case EJECTING:
                rollerIntakeMotor.set(-1.0);
                break;
        }
    } 
    ...
```

Once both the states and the motor controllers are declared, the update function is made. It's main purpose is to take in the current state via the state variable and asign the motorcontrollers or any other relevant objects to preform a task. To determine the task based off of the state is simple switch statement is used. Once the state is determined the task is preformed. In the case of this subsystem a motors turning speeds are changed based off of the state . 

To do this, a function called `set()` is used which has the purpose of taking in a value from -1.0 to 1.0 which tells a motor to either spin backwards or forwards. 

### Making Methods Relating To States

```java

    public void neutral() {
        state = State.NEUTRAL;
    }

    public void eject() {
        state = State.EJECTING;
    }
   
    public void intake() {
        state = State.INTAKING;
    }
    
    public State getState() {
        return state;
    }
}
```
In most subsystems there are two main types of files that always go with states. It's the get functions and the set functions.
`getState()` is a get function as it gets the current state. Meanwhile `eject()`, `intake()`, and `neutral()` are setter functions which set the state variable to the state in the function.

There may be some confusion about why there needs to be functions to set and get the variable instead of just doing it to the variable. Most of it comes down to good programming practice as very often variables are private and they can not be accessed by another class such as a command. Though, functions are almost always public which makes them ideal for that use.

### All The Code In The Lesson Together

Below is all the code that was completed during this lesson. This would make up a fully working subsystem file assuming it has the correct supporting files like commands.
```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {

    private final CANSparkMax rollerIntakeMotor;

    public enum State {
        INTAKE,
        EJECT,
        NEUTRAL
    }

    State state = State.NEUTRAL;

    public RollerIntake() {
        rollerIntakeMotor = new CANSparkMax(ElectricalLayout.INTAKE_MOTOR_ID, MotorType.kBrushless);
        rollerIntakeMotor.restoreFactoryDefaults();
        rollerIntakeMotor.setIdleMode(IdleMode.kBrake);
        rollerIntakeMotor.setSmartCurrentLimit(NEO_550_CURRENT_LIMIT);
    }

    @Override
    public void update() {
        switch(state) {
            case NEUTRAL:
                rollerIntakeMotor.set(0.0);
                break;
            case INTAKING:
                rollerIntakeMotor.set(1.0);
                break;
            case EJECTING:
                rollerIntakeMotor.set(-1.0);
                break;
        }
    }
    
    public void neutral() {
        state = State.NEUTRAL;
    }

    public void eject() {
        state = State.EJECTING;
    }
   
    public void intake() {
        state = State.INTAKING;
    }
    
    public State getState() {
        return state;
    }
}
```
## Conclusion

Now that we have a feel for what a basic subsystem file has we will be exploring how make the constants in our next lesson. If you have any questions or concerns about this lesson, feel free to ask a senior programmer.
