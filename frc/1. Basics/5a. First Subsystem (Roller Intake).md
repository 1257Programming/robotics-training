# First Subsystem(Roller Intake)

Now that we have gone over what Command-Based is and what actuators are, we can now try programming our first subsystem: a Roller Intake.
Before we start programming it, it is important to understand what it actually is.

![intake](img/rollerIntake.jpg)

## Subsystem Description

The image above is of our 2019 Competition: Destination Deep Space. The wheels on the outside of the intake were meant to take in balls by spinning inward. It would then eject the balls by spinning outward. There was also a third state(neutral) where the ball was just supposed to stay in the intake. For the purposes of this example we will assume the wheels are not turning.

These wheels were moved by a motors which were controlled by motor controllers(the things we actually program). For the Purposes of this tuturial we will assume that sparkmaxes were used. Now that we have the subsystem layout out of the way, it's time to start coding!!!!

## Snail Subsystem

Before we make our file to store the subsystem, there is one file we must make which is essential: SnailSubsystem.java. This file is essentially an abstract class that each subsystem class extends in order to gain key abstract functions. For a refresh on what abstract classes are and their uses go our [Polymorphism document](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/4.%20Objects/6.%20Polymorphism.md).

We put this file in the subsystems folder and this is the code that will always be inside of it.

```java

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

public abstract class SnailSubsystem extends SubsystemBase {

    public abstract void update();
    public abstract void outputValues();
    public abstract void setUpConstantTuning();
    public abstract void getConstantTuning();
}

```
.
**Now for the line by line review:**

* The first line simply declares the package that the file is in
* The second line imports the file: SubsystemBase from wpilibj2. While this is not very relleavnt for this part of the lesson the added functiionality becomes very important.
* The next line actually makes the class. Notice that is extends SubsystemBase which means that it inherits multiple useful functions.
* Then the next four lines have four functions which are all abstract funcions which will have to be defined in the subsystems that inherit this class.

## The Actual Subsystem File

Below is the standard template for a subsystem file that our team uses.

```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {


    public enum State {
    }

    public RollerIntake() {
    }
    
    @Override
    public void update() {
    }
    
    public State getState() {
        return state;
    }
    
```

**Now for the line by line review:**

* At the very top of the file is the package listed out
* Then, several imortant imports related to the SPARK MAX(s) that could be used in the subsystem were made.
    - The top import imports the actual file for the motor controller. 
    - The import below it is used for setting the idle  mode to "break".
    - The bottom imports the motor type which is brushless for SPARK MAXs.
* Then come three more import statements that immport to sections of the Constants file(The place where all constants that relate to the robot are stored).
    - The Electrical Layout is where all the motor ID's are stored so the code know which motor to control.
    - The Roller Intake Section has constants that only relate to the subsystem such motor speeds.
* In the next line the class is declared which notably extends SnailSubsystem which means that its abstract functions are inherited.

The next part of the line by line review will be done in sections.

### public enum State

The first chunk of code is when an enum called State is declared. Just like the name suggest, this will keep track of the state of the subsystem. Like previously mentioned a state can be something like intaking or ejecting. Every subsystem will have different states doing different things. If you need a refresher on enums go to our [enums](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/2.%20Control-Flow/7.%20Enums.md) training page .

### public RollerIntake() 

This is the constructor for the subsystem. Things like motors, their settings and certain variables are defined here. Every Subsystem has one.

### public void update() 

This function is responsible for making the robot do things based off of the state. For example, this function could make a motor spin forward if the state was intake. This function is run by the robot 50 times per second during a match so it is very reponsive.

### public State getState()

This function is very self explanatory. It simply returns the state of the robot. That can be very useful when the state needs to be accessed from another file.
