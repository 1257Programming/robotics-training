# First Subsystem(Roller Intake)

Now that we have gone over what Command-Based is and what actuators are, we can now try programming our first subsystem: a Roller Intake.
Before we start programming it, it is important to understand what it actually is.

![intake](img/rollerIntake.jpg)

## Subsystem Description

The image above is of our 2019 Competition: Destination Deep Space. The wheels on the outside of the intake were meant to take in balls by spinning inward. It would then eject the balls by spinning outward. There was also a third state(neutral) where the ball was just supposed to stay in the intake. For the purposes of this example we will assume the wheels are not turning.

These wheels were moved by a motors which were controlled by motor controllers(the things we actually program). For the Purposes of this tuturial we will assume that sparkmaxes were used. Now that we have the subsystem layout out of the way, it's time to start coding!!!!

## Snail Subsystem

Before we make our file to store the subsystem, there is one file we must make which is essential: SnailSubsystem.java. This file is essentially an abstract class that each subsystem class extends in order to gain key abstract functions. For a refresh on what abstract classes are and their uses go our [Polymorphism document](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/4.%20Objects/6.%20Polymorphism.md).

We put this file in the subsystems folder and this is the code that will always be inside of it.

```java

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

public abstract class SnailSubsystem extends SubsystemBase {

    public abstract void update();
    public abstract void outputValues();
    public abstract void setUpConstantTuning();
    public abstract void getConstantTuning();
}

```
.
**Now for the line by line review:**

* The first line simply declares the package that the file is in
* The second line imports the file: SubsystemBase from wpilibj2. While this is not very relleavnt for this part of the lesson the added functiionality becomes very important.
* The next line actually makes the class. Notice that is extends SubsystemBase which means that it inherits multiple useful functions.
* Then the next four lines have four functions which are all abstract funcions which will have to be defined in the subsystems that inherit this class.

## The Actual Subsystem File

Below is the standard template for a subsystem file that our team uses.

```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {


    public enum State {
    }

    public RollerIntake() {
    }
    
    @Override
    public void update() {
    }
    
    public State getState() {
        return state;
    }
}   
```

**Now for the line by line review:**

* At the very top of the file is the package listed out
* Then, several imortant imports related to the SPARK MAX(s) that could be used in the subsystem were made.
    - The top import imports the actual file for the motor controller. 
    - The import below it is used for setting the idle  mode to "break".
    - The bottom imports the motor type which is brushless for SPARK MAXs.
* Then come three more import statements that immport to sections of the Constants file(The place where all constants that relate to the robot are stored).
    - The Electrical Layout is where all the motor ID's are stored so the code know which motor to control.
    - The Roller Intake Section has constants that only relate to the subsystem such motor speeds.
* In the next line the class is declared which notably extends SnailSubsystem which means that its abstract functions are inherited.

The next part of the line by line review will be done in sections.

### public enum State

The first chunk of code is when an enum called State is declared. Just like the name suggest, this will keep track of the state of the subsystem. Like previously mentioned a state can be something like intaking or ejecting. Every subsystem will have different states doing different things. If you need a refresher on enums go to our [enums](https://github.com/FRC1257/robotics-training/blob/Ethan-Subsystem/java/2.%20Control-Flow/7.%20Enums.md) training page .

### public RollerIntake() 

This is the constructor for the subsystem. Things like motors, their settings and certain variables are defined here. Every Subsystem has one.

### public void update() 

This function is responsible for making the robot do things based off of the state. For example, this function could make a motor spin forward if the state was intake. This function is run by the robot 50 times per second during a match so it is very reponsive.

### public State getState()

This function is very self explanatory. It simply returns the state of the robot. That can be very useful when the state needs to be accessed from another file.

## Finished Code

Now that the basic template has been gone over, It's time start programming line by line.

```java

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import frc.robot.Constants;
import static frc.robot.Constants.ElectricalLayout;
import static frc.robot.Constants.RollerIntake.*;

public class RollerIntake extends SnailSubsystem {
    private final CANSparkMax rollerIntakeMotor;

    public enum State {
    INTAKE,
    EJECT,
    NEUTRAL
    }

    State state = State.NEUTRAL;
    
    public RollerIntake() {
        rollerIntakeMotor = new CANSparkMax(ElectricalLayout.INTAKE_MOTOR_ID, MotorType.kBrushless);
        rollerIntakeMotor.restoreFactoryDefaults();
        rollerIntakeMotor.setIdleMode(IdleMode.kBrake);
        rollerIntakeMotor.setSmartCurrentLimit(NEO_550_CURRENT_LIMIT);
    }
    
    @Override
    public void update() {
        switch(state) {
            case NEUTRAL: 
                rollerIntakeMotor.set(Constants.Intake.INTAKE_NEUTRAL_SPEED);
                break;
            case INTAKING:
                rollerIntakeMotor.set(Constants.Intake.INTAKE_INTAKE_SPEED);
                break;
            case EJECTING:
                rollerIntakeMotor.set(Constants.Intake.INTAKE_EJECT_SPEED);
                break;
    }
}
    
    public State getState() {
        return state;
    }
}    
```

Now with all  of the code in, lets talki about what it does.

1. After the import statements, the motor controller is declared. Though, it is not defined. This is so it could be defined and accessed later in the code.

2. After that, the states are declared in enum. The three states declared are INTAKE, EJECT, and NEUTRAL. The state was then set to neutral. This makes logical sense as when the robot just turns on it should not be moving until given the command.

3. Then comes the constructor. For the most part all that is being done here is the defining of the motor conroller and the settings. All of these lines are wrtitten with the format of  rollerIntakeController.something. This signfied that these are functions that belong to the object that we created.

   a.when  declaring a Spark Max motor conroller, there are two parameters: The motor ID which is currently an undefined variable and      the motorype. Since the motors we use are brushless that is what we put in the parameter.
   
   b. `restoreFactoryDefaults()` does what it says. It just makes sure the the settings are what they should be.
   
   c. The next line sets idle mode to break. Almost all of our motors except for drive are set to break as that ensures that the motors    will come to a stop if they are not directed to move.
   
   d. Lastly we set the current limit. If a motor experiences too much current it could get seriously damaged. This iline of code makes     sure themotornever gets to that point.
   
4. In the update function, a switch statement was used to do certain actions with the motor by using the motor controller that was just created based off of the current state. `set()` is a function that takes in a value from -1.0 to 1.0 which tells a motor to either spin forwards or backwards. Currently the parameters are from the constant file that has yet to be created.

5. The rest of the code is as it was before.

## Conclusion

Now that we have a feel for what a basic subsystem file has we will be exploring how make the constants in a short lesson. If you have any questions or concerns, feel free to ask a senior programmer.
