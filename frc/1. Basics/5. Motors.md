# Motors

## Terminology

An actuator is defined as "a component of a machine that is responsible for moving and controlling a mechanism or system." For our purposes, we need only consider *motors* and *pneumatics*. 

Our robot is essentially entirely made up of motors. All moving components are controlled by motors or pneumatics, and our job as programmers is to figure out how to convert drive team input into the robot actually doing its job. For instance, programming will make sure that certain motors move when drive team pushes buttons or joysticks on the controller.

First, some clarification:

- *Motor* - the actual physical part that spins
- *Motor Controller* - facilitator that takes in and sends signal to control the motor accordingly

Motors are widely used throughout most, if not all of our robot's subsystems, e.g. on the drivetrain. At the time of writing, 1257 mainly used NEO Brushless and NEO 550 motors, by REV Robotics. 

<img src="img/SPARKMAX.png" width="330" height=""> <img src="img/NEOvs550.png" width="330"> 

To control these motors and actually manipulate a robot mechanism, we interface with the corresponding motor controllers--this is what we do in code. The SPARK MAX controller (also by REV Robotics) is used with NEO-type motors. 

## Setup

Here, we'll write in the iterative programming paradigm for brevity. Examples for command-based programming will follow in the next few files.

```java
package frc.robot;

import edu.wpi.first.wpilibj.*;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

public class Robot extends TimedRobot {

    private final CANSparkMax motor;
    
    @Override
    public void robotInit() {
        motor = new CANSparkMax(0, MotorType.kBrushless);
        motor.setIdleMode(IdleMode.kBrake);
        motor.setSmartCurrentLimit(80);

    }

    @Override
    public void teleopPeriodic() {

    }
}
```

We've done a couple things so far:

1. Set and declared a CANSparkMax motor controller with ID 0
2. Configured the controller to work with a Brushless motor (i.e. NEO/NEO 550)
3. Set the motor to "brake" mode
4. Set a current limit of 80 amps to the motor
4. Done all of the above with the corresponding vendor dependency file and imports

Read more here on [brushed vs. brushless motors](https://cordlessdrillzone.com/drill-wars/brushless-vs-brushed-motor/) and [Brake vs. Coast mode](https://www.chiefdelphi.com/t/what-is-brake-coast-mode/163649). As for current limiting, it's just good practice to set that limit as a safety, such that risk of overdrawing/breaking the motor is reduced.

A great feature of the SPARK MAX controller is that it can handle both brushless (NEO) and brushed motors (CIM, miniCIM, BAG, etc). This versatility is very convenient for teams that have many brushed motor spares, as it allows for quick motor replacement if a NEO/NEO 550 is broken. If a motor change from brushless to brushed is made, all that needs to be updated is `MotorType.kBrushless` to `MotorType.kBrushed`, and vice versa.

## Controlling the Motor

Now that we have created the motor object, we have to control it. Doing so is very simple:

```java
package frc.robot;

import edu.wpi.first.wpilibj.*;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import frc.robot.util.SnailController; // new

public class Robot extends TimedRobot {

    private final CANSparkMax motor;
    private final SnailController controller; // new
    
    @Override
    public void robotInit() {
        motor = new CANSparkMax(0, MotorType.kBrushless);
        motor.setIdleMode(IdleMode.kBrake);

        controller = new SnailController(0); // new
    }

    @Override
    public void teleopPeriodic() { // new
        if (controller.getAButton()) {
            motor.set(1.0);
        }

        if (controller.getXButton()) {
            motor.set(-1.0);
        }

    }
}
```

New additions: 

1. Declared and set up a `SnailController` object
2. Imported the `SnailController` class
3. During teleop: if the A button is pressed, the motor will be run full speed *forward*
4. During teleop, if the X button is pressed, the motor will be run full speed *reverse*

As such, controlling a motor is pretty simple. What's more complex is controlling that motor *accurately*--more to follow on this soon!

To apply power to a motor, we simply use `motor.set(VALUE)`. "VALUE" is a decimal between -1.0 and 1.0, with 1.0 meaning full speed forward, 0.0 meaning no speed/movement, and -1.0 meaning full speed reverse.

## Note

SPARK MAX controllers are not the only ones we could use--in the past, 1257 has used Talon SRXs, Victor SPXs, and more. 

While the motor controller may differ, the general process of controlling the motor is most the same. If Talon SRXs were being used, changes would be to the class name (now `WPI_TalonSRX`) and any functions taken from that class (e.g. `setIdleMode()` would go to `setNeutralMode()`).
