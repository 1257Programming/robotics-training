# First Bindings(Roller Intake)

Now that we have created the commands we now need away to actually call/use them. This is where the bindings come in. All of the comands are binded to certain buttons on the Xbox controller so we can actually control the robot with our controller. In `RobotContainer`, we will actually do the bindings. Certain functions in this file will not be include for simplicity sake so read other lessons to get a full picture of what this file should entail.

## Robot Container File Format

Below is the basic format of the `Robot Container` File. This tutorial does not explain all of the functions that will be inside of it as they will be covered in future lessons

```java
package frc.robot;
import edu.wpi.first.wpilibj2.command.Command;

import frc.robot.commands.intake.RollerIntakeNeutralCommand;
import frc.robot.commands.intake.IntakeIntakeNeutralCommand;
import frc.robot.commands.intake.EjectIntakeNeutralCommand;

import frc.robot.util.SnailController;

import static frc.robot.Constants.ElectricalLayout.CONTROLLER_DRIVER_ID;
import static frc.robot.Constants.ElectricalLayout.CONTROLLER_OPERATOR_ID;

public class RobotContainer {

    private final SnailController driveController;
    private final SnailController operatorController;

    private final ArrayList<SnailSubsystem> subsystems;

    private Notifier updateNotifier;
    private int outputCounter;

    public RobotContainer() {
        driveController = new SnailController(CONTROLLER_DRIVER_ID);
        operatorController = new SnailController(CONTROLLER_OPERATOR_ID);

        // declare each of the subsystems here

        subsystems = new ArrayList<>();
        // add each of the subsystems to the arraylist here

        configureAutoChoosers();
        configureButtonBindings();
        outputCounter = 0;

        SmartDashboard.putBoolean("Testing", false);

        updateNotifier = new Notifier(this::update);
        updateNotifier.startPeriodic(UPDATE_PERIOD);
    }

    /**
     * Define button -> command mappings.
     */
    private void configureButtonBindings() {

    }

    ...
}
```

## Package and Imports Overview

* The package is very self explanatory. It is in the robot folder which is inside of frc.
* Next, the commands we already created are imported. They are needed so they can be binded to the controller buttons
* Next comes the `SnailController` import, which is used to make the xBox controllers.
* Lastly the constants for the controller ports are imported.

## Function Overview

### `RobotContainer()`

This is the constructor for the class. The `SnailController`s (1257 Xbox Controllers with extra functionality), the subsystems and their default commands are defined here. In more complicated subsystems, other objects may also be defined here. We have a lot going on in the constructor, but you only have to worry about the areas where we define and register subsystems.

### `configureButtonBindings()`

This function is where all the button bindings actually happen. Specifically, when a certain button is pressed on a certain controller, a certain command gets run.

### Others

There are many more functions, but we will cover them later when we go over advanced topics such as diagnostic data and autonomous mode.

## Adding Functionality

### The Constructor

```java
private final SnailController driveController;
private final SnailController operatorController;

private final RollerIntake rollerIntake;
private final ArrayList<SnailSubsystem> subsystems;

private Notifier updateNotifier;
private int outputCounter;


public RobotContainer() {
    driveController = new SnailController(CONTROLLER_DRIVER_ID);
    operatorController = new SnailController(CONTROLLER_OPERATOR_ID);

    rollerIntake = new RollerIntake(); // NEW
    rollerIntake.setDefaultCommand(new RollerIntakeNeutralCommand(rollerIntake)); // NEW

    subsystems = new ArrayList<>();
    subsystems.add(rollerIntake); // NEW

    configureAutoChoosers();
    configureButtonBindings();
    outputCounter = 0;

    SmartDashboard.putBoolean("Testing", false);

    updateNotifier = new Notifier(this::update);
    updateNotifier.startPeriodic(UPDATE_PERIOD);
}

```

* First, we create an instance of our rollerIntake and define it in the constructor
* Then, the default command for the `RollerIntake` sent. A default command is a command that runs for a subsystem when no other command is scheduled. Since we do not want the robot to do anything until we press a button, we set the default command to the `RollerIntakeNeutralCommand`. Once we do this, our command's `initialize()` function will be ran, and then it's `periodic()` function will be looped constnatly.
* Next, we have to "register" our subsystem within the `ArrayList` called `subsystems`. Don't worry if you don't know what an `ArrayList` is, but it's just simply a list of objects. We use it to keep track of all of our subsystems and running their various extra functionality.

### Binding Commands To The Buttons

```java
private void configureButtonBindings() {
    operatorController.getButton(Button.kX.value).whileActiveOnce(new RollerIntakeEjectCommand(rollerIntake));
    operatorController.getButton(Button.kA.value).whileActiveOnce(new RollerIntakeIntakeCommand(rollerIntake));
}
```

In short, the X button is being binded to run `RollerIntakeEjectCommand`, while the A button is being binded to run`RollerIntakeIntakeCommand`.

Now let's, do the long explanation.

#### getButton()

* When this function is run, it returns a JoystickButton object that corresponds to a physical button on teh controller. The format for the parameter is Button.k(button).value. So in the first case it would return the X button. (You will probably need an `import` statement for the `Button` class)
* Now that a `JoystickButton` object has been returned, a multitude of functions can be used to actually bind a command to certain actions 

#### Button Binding Functions

There are many, many functions you can choose from, but we will go over a few of them here.

**`whenPressed()`** This function means that when the button is pressed, the command is run once and then it reverts to the default command immediately. This is useful for quick actions that we do not want to run for a period of time.

**`whenReleased()`** This function means that when the button is released, the command is run once and then it reverts to the default command immediately. This is useful for quick actions that we do not want to run for a period of time.

**`whileActive()`** This function runs the command constantly as the button is held down. It will constantly reinitialize and when the button is let go, the command will stop being run. We typically don't use this and instead choose to use `whileActiveOnce()`.

**`whileActiveOnce()`** This function runs the command when the button is first held down and will continue running as long as the button stays down. It will NOT reinitialize constantly as you hold the button. When the button is let go, the command will be cancelled and the default command will likely begin running.

**`toggleWhenPressed()`** This function will toggle the command to constantly be run when the button is first pressed. When the button is released, the command will continue running until the button is pressed again and retoggles it.

##### Note: There is also a function in our controller to use Xbox triggers. Triggers unfortunately have a bit of a different naming convention, so see the below link for details on that

For even more functions, see [the WPILib docs](https://docs.wpilib.org/en/latest/docs/software/commandbased/binding-commands-to-triggers.html).

#### The Function We Chose

Since we want the motors to spin as long as the button is pressed, we use the `whileActiveOnce()` function. We don't want the command to be constantly run since that would just be a waste, which is why we use the `Once()` version. Inside of the parentheses is the argument, which is the command we want to use. We use the `new` keyword here to create a quick object from our command, since we need to pass an object into the function.

## All The Code In The Lesson

Here is all of the code covered in this lesson.

```java
package frc.robot;

import frc.robot.commands.intake.RollerIntakeNeutralCommand;
import frc.robot.commands.intake.IntakeIntakeNeutralCommand;
import frc.robot.commands.intake.EjectIntakeNeutralCommand;

import frc.robot.util.SnailController;
import edu.wpi.first.wpilibj.XboxController.Button;

import static frc.robot.Constants.ElectricalLayout.CONTROLLER_DRIVER_ID;
import static frc.robot.Constants.ElectricalLayout.CONTROLLER_OPERATOR_ID;

public class RobotContainer {

    private final SnailController driveController;
    private final SnailController operatorController;

    private final RollerIntake rollerIntake;
    private final ArrayList<SnailSubsystem> subsystems;

    private Notifier updateNotifier;
    private int outputCounter;


    public RobotContainer() {
        driveController = new SnailController(CONTROLLER_DRIVER_ID);
        operatorController = new SnailController(CONTROLLER_OPERATOR_ID);

        rollerIntake = new RollerIntake();
        rollerIntake.setDefaultCommand(new RollerIntakeNeutralCommand(rollerIntake));

        subsystems = new ArrayList<>();
        subsystems.add(rollerIntake);

        configureAutoChoosers();
        configureButtonBindings();
        outputCounter = 0;

        SmartDashboard.putBoolean("Testing", false);

        updateNotifier = new Notifier(this::update);
        updateNotifier.startPeriodic(UPDATE_PERIOD);
    }

    private void configureButtonBindings() {
        operatorController.getButton(Button.kX.value).whileActiveOnce(new RollerIntakeEjectCommand(rollerIntake));
        operatorController.getButton(Button.kA.value).whileActiveOnce(new RollerIntakeIntakeCommand(rollerIntake));
    }
}
```

## Final Remarks

With that, we're done! Hopefully you can try this out on a robot and see the results! This is one of the first and most basic subsystems we can program, but you can be sure that we will learn how to program much, much more! We're going to go over a few more common subsystems, starting with another style of intake: a claw intake.
