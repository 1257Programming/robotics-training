# First Bindings (Roller Intake)

Now that we have created the commands, we need a way to actually call/use them. This is where bindings come in. All of the commands are bound to certain buttons/triggers on an Xbox controller so we can control the robot. 

Button bindings are created in the file `RobotContainer.java.` Certain parts in this file will be omitted for brevity, so read other lessons to get a full picture of what `RobotContainer` entails.

## Robot Container Format

Below is the basic format of the `RobotContainer` file:

```java
package frc.robot;

import edu.wpi.first.wpilibj2.command.Command;

import frc.robot.commands.intake.RollerIntakeNeutralCommand;
import frc.robot.commands.intake.IntakeIntakeNeutralCommand;
import frc.robot.commands.intake.EjectIntakeNeutralCommand;
import frc.robot.util.SnailController;

import static frc.robot.Constants.ElectricalLayout.CONTROLLER_DRIVER_ID;
import static frc.robot.Constants.ElectricalLayout.CONTROLLER_OPERATOR_ID;

public class RobotContainer {

    private final SnailController driveController;
    private final SnailController operatorController;

    public RobotContainer() {
        driveController = new SnailController(CONTROLLER_DRIVER_ID);
        operatorController = new SnailController(CONTROLLER_OPERATOR_ID);

        configureButtonBindings();
    }

    /**
     * Define button -> command mappings.
     */
    private void configureButtonBindings() {

    }

    ...
}
```

### Package and Imports Overview

* The package is very self explanatory. It is in the /robot folder which is inside of /frc.
* Next, the commands we already created are imported. They are needed so they can be binded to the controller buttons.
* Next comes the `SnailController` import, which is used for the Xbox controllers.
* Lastly, the constants for the controller ports are imported.

### `RobotContainer()`

This is the constructor for the class. The `SnailController`s, the subsystems, and their default commands are defined here. In more complicated subsystems, other objects may also be defined here. We have a lot going on in the constructor, but for now you'll only have to think about initializing subsystems/controllers and calling certain functions. 

### `configureButtonBindings()`

This function is where all the button bindings actually happen, and is where we'll mainly work in this lesson. In other words, we add functionality such that a button press will call a specific command.

### Others

There are more functions, but we will cover them later when we go over advanced topics such as diagnostic data and autonomous mode.

## Adding Functionality

### The Constructor

```java
    ...

    private final SnailController driveController;
    private final SnailController operatorController;

    private final RollerIntake rollerIntake;

    public RobotContainer() {
        driveController = new SnailController(CONTROLLER_DRIVER_ID);
        operatorController = new SnailController(CONTROLLER_OPERATOR_ID);

        rollerIntake = new RollerIntake(); // NEW
        rollerIntake.setDefaultCommand(new RollerIntakeNeutralCommand(rollerIntake)); // NEW

        configureButtonBindings();
    }

```

* First, we instantiate `rollerIntake` and define it in the constructor.
* Then, the "default command" for the `RollerIntake` is set. A default command is a command that runs for a subsystem when *no other* command is scheduled. Since we do not want the robot to do anything until we press a button, we set the default command to the `RollerIntakeNeutralCommand` (having the intake run at a low, constant speed).
* Next, we actually call `configureButtonBindings()` in the constructor. This is so that the function runs when `RobotContainer` is instantiated.

### Binding Commands 

```java
private void configureButtonBindings() {
    operatorController.getButton(Button.kX.value).whileActiveOnce(new RollerIntakeEjectCommand(rollerIntake));
    operatorController.getButton(Button.kA.value).whileActiveOnce(new RollerIntakeIntakeCommand(rollerIntake));
}
```

In short, the X button is being set to run `RollerIntakeEjectCommand`, while the A button is being set to run `RollerIntakeIntakeCommand`.

Now for the long explanation.

#### getButton()

* When this function is run, it returns a [JoystickButton](https://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj2/command/button/JoystickButton.html) object that corresponds to a physical button on the controller. The format for the parameter is `Button.k(button).value`, where "button" is the chosen button. In the first case it would return the X button, and the A button for the second. (You will probably need an `import` statement for the `Button` class).
* Now that a `JoystickButton` object has been returned, a multitude of functions can be used to actually bind a command to certain actions. 

#### Button Binding Functions

There are many, many functions you can choose from, but we will go over a few of them here.

**`whenPressed()`** - When the button is pressed, the command is run once and then it reverts to the default command immediately. This is useful for quick actions that we do not want to run for a period of time.

**`whenReleased()`** - When the button is released, the command is run once and then it reverts to the default command immediately. This is also useful for quick actions that we do not want to run for a period of time.

**`whileActive()`** - Runs the command constantly as the button is held down. It will constantly schedule the command, but stops when the button is let go. We typically don't use this and instead choose to use `whileActiveOnce()`.

**`whileActiveOnce()`** - Runs the command when the button is first held down and will continue running for as long as the button stays down. If the command ends while the button is still active, it will *not* be rescheduled. This is why we returned false in `isFinished()`, if you recall. When the button itself is let go, the command will be cancelled and the default command will begin running.

**`toggleWhenPressed()`** - This function will toggle the command to constantly be run when the button is first pressed. When the button is released, the command will continue running until the button is pressed again and retoggles it.

**(Note: There is also a function in our controller to use Xbox triggers. Triggers unfortunately have a bit of a different naming convention, so see the below link for details on that)**

See [here](https://docs.wpilib.org/en/latest/docs/software/commandbased/binding-commands-to-triggers.html) for more controller/joystick functions from WPILib.

#### The Function We Chose

Since we want the motors to spin as long as the button is pressed, we use the `whileActiveOnce()` function. Once again, since we return false in `isFinished()`, we choose `whileActiveOnce()`. 

Inside of the parentheses is the argument, which is the command we want to use. We use the `new` keyword here to create a quick object from our command, since we need to pass an object into the function.

<hr>

Here is all of the code covered in this lesson.

```java
package frc.robot;

import frc.robot.commands.intake.RollerIntakeNeutralCommand;
import frc.robot.commands.intake.IntakeIntakeNeutralCommand;
import frc.robot.commands.intake.EjectIntakeNeutralCommand;

import frc.robot.util.SnailController;
import edu.wpi.first.wpilibj.XboxController.Button;

import static frc.robot.Constants.ElectricalLayout.CONTROLLER_DRIVER_ID;
import static frc.robot.Constants.ElectricalLayout.CONTROLLER_OPERATOR_ID;

public class RobotContainer {

    private final SnailController driveController;
    private final SnailController operatorController;

    private final RollerIntake rollerIntake;

    public RobotContainer() {
        driveController = new SnailController(CONTROLLER_DRIVER_ID);
        operatorController = new SnailController(CONTROLLER_OPERATOR_ID);

        rollerIntake = new RollerIntake();
        rollerIntake.setDefaultCommand(new RollerIntakeNeutralCommand(rollerIntake));

        configureButtonBindings();
    }

    private void configureButtonBindings() {
        operatorController.getButton(Button.kX.value).whileActiveOnce(new RollerIntakeEjectCommand(rollerIntake));
        operatorController.getButton(Button.kA.value).whileActiveOnce(new RollerIntakeIntakeCommand(rollerIntake));
    }

    ...
}
```

## Final Remarks

With that, we're done! We've created a fully functional subsystem with bound commands. Hopefully you can try this out on a robot and see the results yourself. 

This is one of the first and most basic subsystems we can program, but you can be sure that we will learn how to program much, much more! We're going to go over a few more common subsystems, starting with another style of intake: a claw intake.
