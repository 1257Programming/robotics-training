# Position PID

Now that we have a basic overview of what PID does (for a quick summary, we use a combination of various terms to drive our error in some field to 0. For instance, our error could be our distance from the setpoint, our difference between desired velocity and current velocity, our angular displacement from a setpoint, etc.)

Right now, we will go over position PID, or PID that tries to bring a mechanism to a desired position. In this case, our `error` term will be the difference between our currently measured position and our desired position. We use position PID very often in robotics. For instance, we frequently use it on our drivetrain to turn to angles and to drive specific distances. Additionally, on mechanisms such as arms or elevators, we use them to go to specific setpoints that allow us to score game pieces.

There are two main implementations of PID that we can use, `PIDController` on the RoboRIO or SPARK MAX onboard PID. For RoboRIO PID, we run a PID controller on the RoboRIO itself and it then sends those calculations to the motor controller. This works no matter what type of motor controller you are using. It is also highly customizable. However, we can also use SPARK MAX onboard PID, which is built into the SPARK MAX motor controller and allows us to run PID commands on the actual motor controller. When we run onboard PID, it can run at much, much faster rates than what is possible on the RoboRIO board.

As a result, it is most of the time desirable to use the SPARK MAX PID when possible. However we cannot use it when we either do not have SPARK MAXes on our mechanism or we have to do some customization with the outputs of our PID controller. Here, we will go over both of the methods.

## RoboRIO PIDController

When we run RoboRIO PID, we use the WPILib `PIDController` class to handle the PID calculations. We will start with the below subsystem (an elevator) and add PID functionality to it.

```java
public class Elevator extends SnailSubsystem {

    public enum State {
        MANUAL
    }

    private WPI_TalonSRX primaryMotor;

    private State state = defaultState;
    private double speed;

    public Elevator() {
        primaryMotor = new WPI_TalonSRX(ELEVATOR_PRIMARY_MOTOR_ID);
        primaryMotor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
        primaryMotor.configSelectedFeedbackCoefficient(1 / 4096.0 / 48.0 * Math.PI * 6);

        primaryMotor.setSelectedSensorPosition(0);
    }

    @Override
    public void update() {
        switch(state) {
            case MANUAL:
                primaryMotor.set(speed);
            break;
        }
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    @Override
    public void outputValues() {
        SmartDashboard.putNumber("Elevator Position", primaryMotor.getSelectedSensorPosition());
    }

    ...
}
```

Currently, we only have the `MANUAL` state set up. In order to implement PID control, we need to add another state, `PID`. However before we do that, let's review some information about [`PIDController`](https://first.wpi.edu/FRC/roborio/release/docs/java/edu/wpi/first/wpilibj/controller/PIDController.html) in WPILib.

### PIDController

The first thing we do when we create a `PIDController` is that we have to initialize its constants with its constructor. We are also given the option to specify the period, or how often the controller is being updated. The default is 0.02 seconds, which is for a 50 Hz update period, but we actually run our controllers twice as fast, at an update rate of 100 Hz. As a result, we need to use the `UPDATE_PERIOD` variable inside of `Constants.java` since it will have the actual period.

After we declare our `PIDController`, we have a variety of options that we can configure. We can configure things such as its tolerance for how close it can be to the setpoint before ending with `setTolerance()`. We can also change the PID constants (good for tuning constants). However once we have everything set up, we can finally use some of the functions to run it.

- `setSetpoint()`: choose where this PIDController is bringing us.
- `atSetpoint()`: returns whether or not we have reached the setpoint
- `calculate()`: takes in the current position of our mechanism and returns the output calculated by the PID controller to get us there
- `reset()`: resets the integral and derivative term. Good for right before we start using PID control

### Implementing PIDController

Now that we've discussed the properties of `PIDController`, we can move on to actually implementing it. First, we want to set up the constants for it in `Constants.java`. We use an array to store all of our PID constants.

```java
public final class Constants {

    public static class ElectricalLayout {
        public final static int CONTROLLER_DRIVER_ID = 0;
        public final static int CONTROLLER_OPERATOR_ID = 1;

        public final static int ELEVATOR_PRIMARY_MOTOR_ID = 4;
    }

    public static class Autonomous {

    }

    public static class Elevator {
        public static double[] ELEVATOR_PID = new double[] {0.1, 0, 0.01};
        public static double ELEVATOR_PID_TOLERANCE = 0.1;
        public static double ELEVATOR_PID_MAX_OUTPUT = 0.7;
    }

    public static double PI = 3.14159265;
    public static double UPDATE_PERIOD = 0.010; // seconds
}
```

Next, we can create our `PIDController` in `Elevator`.

```java
public class Elevator extends SnailSubsystem {

    public enum State {
        MANUAL
    }

    private WPI_TalonSRX primaryMotor;

    private PIDController elevatorPID;

    private State state = defaultState;
    private double speed;

    public Elevator() {
        primaryMotor = new WPI_TalonSRX(ELEVATOR_PRIMARY_MOTOR_ID);
        primaryMotor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
        primaryMotor.configSelectedFeedbackCoefficient(1 / 4096.0 / 48.0 * Math.PI * 6);

        primaryMotor.setSelectedSensorPosition(0);

        elevatorPID = new PIDController(ELEVATOR_PID[0], ELEVATOR_PID[1], ELEVATOR_PID[2], UPDATE_PERIOD);
        elevatorPID.setTolerance(ELEVATOR_PID_TOLERANCE);
    }

    ...
}
```

After this, we can add the state `PID` to our state list. In the `PID` state, we want to get our `PIDController` and calculate its output using our current sensor info. Then, we want to send this to the motor. Another thing we want to do is check if we are at our current setpoint. If we are, we want to end the `PID` state and go back to `MANUAL`. Another thing to note is that we might want to constrict the max output of our PID controller to ensure that the system moves at a slow and controllale pace. We can directly modify the output from our `PIDController` to do this.  Note that we have not implemented actually setting up the setpoint yet. This will be handled later.

```java
public class Elevator extends SnailSubsystem {

    public enum State {
        MANUAL,
        PID
    }

    ...

    @Override
    public void update() {
        switch(state) {
            case MANUAL:
                primaryMotor.set(speed);
            break;
            case PID:
                double output = elevatorPID.calculate(primaryMotor.getSelectedSensorPosition());
                if(output > ELEVATOR_PID_MAX_OUTPUT) output = ELEVATOR_PID_MAX_OUTPUT;
                if(output < -ELEVATOR_PID_MAX_OUTPUT) output = -ELEVATOR_PID_MAX_OUTPUT;

                primaryMotor.set(output);

                if(elevatorPID.atSetpoint()) {
                    state = State.MANUAL;
                }
            break;
        }
    }
}
```

Now that we've handled the state, it's time to handle actually triggering the state with one of our functions. We can make this function called `setPosition()` that will handle this. In this function we want to

- enter the `PID` state
- reset our `PIDController`
- set our `PIDController` setpoint

```java
public void setPosition(double setpoint) {
    state = State.PID;
    elevatorPID.reset();
    elevatorPID.setSetpoint(setpoint);
}
```

We will review writing the command for this after we go over SPARK MAX PID. Click [here](##PID-Command) to go straight there.

## SPARK MAX PID

TODO

## PID Command

TODO

## Extras

Now that we've implemented our PID controllers, it's time to go over some additional things.

### Displaying Data

One **extremely** useful thing you can do while tuning PID is to make graphs, graphs, and tons of graphs. The best one you can make is one that has both your current position and your setpoint on it. A really convenient way to output the data is actually to output the current position and the setpoint in the same array, which will automatically make Shuffleboard put a graph of them on the screen together.

`PIDController`

```java
public void outputValues() {
    SmartDashboard.putNumberArray("Elevator Dist PID", new double[] {primaryMotor.getSelectedSensorPosition(), elevatorPID.getSetpoint()});
}
```

SPARK MAX PID

```java
public void outputValues() {
    SmartDashboard.putNumberArray("Elevator Dist PID", new double[] {primaryEncoder.getPosition(), pidSetpoint});
}
```

### Shuffleboard Tuning

Shuffleboard tuning is rather straightforward with `PIDController`. We can simply query Shuffleboard for the constant and then once we get this new value, we do two things:

- we store it in the `ELEVATOR_PID` array in Constants
- we update `PIDController` with this new constant

```java
@Override
public void getConstantTuning() {
    ELEVATOR_PID[0] = Shuffleboard.getNumber("Elevator PID P", ELEVATOR_PID[0]);
    ...

    elevatorPID.setP(ELEVATOR_PID[0]);
    ...
}
```

For the SPARK MAX PID controller, it gets just a bit more tricky. For SPARK MAX, the controller will glitch out if you try to constantly do `elevatorPID.setP()` calls over and over again, even if you're setting it to the same value. As a result, you have to do a check to make sure you're only updating the value when it actually changes.

```java
@Override
public void getConstantTuning() {
    ELEVATOR_PID[0] = Shuffleboard.getNumber("Elevator PID P", ELEVATOR_PID[0]);
    ...

    if(elevatorPID.getP() != ELEVATOR_PID[0]) elevatorPID.setP(ELEVATOR_PID[0]);
    ...
}
```

### Why We Might Use PIDController on a SPARK MAX

Sometimes, we might choose to use the RoboRIO `PIDController` over the SPARK MAX because `PIDController` gives us way more flexibility in terms of what we do with that output. For instance, when we do PID control on our drivetrain to drive a straight distance, we use `PIDController` because it allows us to pass that value into the `arcadeDrive()` function and then pass another custom variable for turning speed into the second parameter of `arcadeDrive()`. If we used the onboard SPARK MAX PID, then we would not be able to do this since the calculated PID value would automatically be sent to the motor on a per controller basis.
