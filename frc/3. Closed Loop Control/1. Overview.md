# Overview of Closed Loop Control

Up until now, we have been using pretty much entirely `open loop control`, which is when the value that we sent to our actuators is determined solely by the input from something like a controller and does not use sensor feedback. For what we've dealth with so far, where we wanted the user to be able to be able to control the mechanisms speed via a joystick or a button press, this has worked fine. However, if we wanted to do something such as move our mechanism to a setpoint, this becomes more difficult. For instance, in the 2019 game, we had 2 differerent setpoints for our arm that we used for scoring the cargo balls.

## Naive Solution

One might try to solve this problem by using timing. For instance, if we wanted to drive forward 10 feet, we could just time how long our robot takes to go 10 feet when we apply 70% power forward and then use that timing to allow our drivetrain to go at that speed.

However, this solution generally does not work, for a variety of different reasons. First of all, there are unpredictable factors that can cause the exact velocity of our wheels to not be exactly the same even if we apply the same power. Chain slipping, friction, foreign obstructions, slop, etc. can all affect the system. Additionally, any obstacles or disturbances in the system can affect it. Most importantly, if we have no sensors on our system, we have no way of knowing our starting position, which makes it difficult to go to absolute positions.

## Closed Loop Control

In closed loop control, we add that sensor feedback to make our control over our system MUCH better. We have a variety of different techniques that can use these sensors to get our desired behavior from the system, as long as our sensors are actually measuring that behavior. For instance, we can use sensors and closed loop control to either bring our mechanism to a certain position, or we could use them to make our mechanism move at a specified velocity.

## Common Types of Closed Loop Control

### Bang Bang Control

Bang bang control is the simplest type of closed loop controller. We simply check if our sensor reading is less than the desired value, and if it is, then we apply a motor output that will bring us towards the desired value. If the sensor reading is greater than the desired value, then we apply the reverse output. This is generally unstable and not recommended since the mechanism can bounce aggressively between the two sides of the setpoint.

### PID Control on Position/Velocity

We will go over this in the next few tutorials. We use these most often.

## Vocabulary

Setpoint / Reference: the desired state of our mechanism
Error: Setpoint - Actual, or how far off you are from your setpoint
Steady-State Error: the error of the system after it has reached equilibrium (stopped moving)
Response: behavior of a system after enabling closed loop control
Settling Time: the time it takes for a system to settle to equilibrium

I've tried to put the most important ones above but here are some more: [Controls Glossary](https://docs.wpilib.org/en/latest/docs/software/advanced-control/introduction/controls-glossary.html)

## Zeroing Sensors

When we have sensors on our system, they will frequently drift due to various reasons, which can make going to absolute positions gradually worse and worse as we continue to use our mechanisms. As a result, we frequently have a limit switch at the end of our mechanism that allows us to "zero" our sensor reading. For instance, if we had an encoder on our arm that was measuring the angle that it was at, we might include a limit switch at the bottom that will zero the encoder's position when it hits the bottom. This not only allows us to zero the reading as the match progresses (since we will inevitably put our arm down), but it also gives us a way to recalibrate our arm if we know there are issues.

### When to Zero the Switch

When we try to apply the above, we sometimes run into issues where after the button is first pressed, the mechanism might still have some leeway and continue to press the button as it goes deeper. Then, once it goes back up, it will take some time for the button to stop being pressed and rise up, which means that while the system is rising, the sensor value is staying at zero (because we are constantly zeroing it). This can have **extremely** unpredictable behavior, especially when we throw in PID controllers with their integral and derivative terms (more on that in the next few guides).

As a result, we change when we zero the sensor. We use a system where we will only trigger the zeroing on something called the "rising edge" or "falling edge" of the switch's signal. A rising edge is when the signal first goes from false to true, and the falling edge is when it first goes from true to false (you can think of true as climbing up a mountain and false as the normal ground as sort of an analogy). This allows us to avoid the constant zeroing problem since our sensor will not only be zeroed at two points instead of continuously.

Most of the time we should use the edge that corresponds to when the mechanism first comes in contact with the switch. This is because then as the mechanism is rising up, it will not trigger a zero in the middle of its movement.

To perform this in code, we need to just store the last switch that we read in and then compare it with the current one to see if we should zero the sensor.

Old Code:

```java
public class Arm extends SnailSubsystem {
    ...

    DigitalInput limitSwitch;

    ...

    public void update() {
        if(limitSwitch.get()) encoder.setPosition(0);
    }
}
```

New Code:

```java
public class Arm extends SnailSubsystem {
    ...

    DigitalInput limitSwitch;

    boolean lastLimitSwitch;

    ...

    public void update() {
        if(!lastLimitSwitch && limitSwitch.get()) encoder.setPosition(0); // rising edge

        lastLimitSwitch = limitSwitch.get();
    }
}
```
